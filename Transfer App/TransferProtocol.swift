//
//  TransferProtocol.swift
//  Transfer App
//
//  Created by van on 18.10.2023.
//

import Foundation

// Такой подход позволяет скрыть за протоколом внутреннюю реализацию и кон- кретный тип контроллера, а значит при необходимости использовать любой вью контроллер, соответствующий протоколу UpdatingDataController.
protocol UpdatingDataTransferProtocol: class {
    var updatingData: String {get set}
}

protocol UpdatableDataTransferProtocol: class {
    var updatedData: String {get set}
}


// Provide use reference instead value type
// As a result back transfer don't need anymore
class AppData {
    var data: String
    init(data: String) {
    self.data = data }
}


//Использование паттерна «Одиночка»
//Еще одним вариантом, который часто используют программисты, является применение шаблона проектирования «Одиночка» (Singleton). Напомню, что данный шаблон подразумевает единую точку входа в класс и один экземпляр этого класса на все приложение:
//class User {
//static shared = User()
//var id: Int = 0 init() {
// ... }
//Среди многих программистов данный шаблон считается антипаттерном. Его критикуют и не любят. Но лично я отношусь к нему более сдержанно и исполь- зую его в тех случаях, когда работа приложения очень тесно связана с экзем- пляром данного типа, и растрата памяти на его постоянное хранение оправдана.


//TODO
// MARK: implement Coordinators method
//
//Для чего нужны координаторы?
//Они сводят к минимуму связанность контроллеров, позволяя сделать их по-на- стоящему независимыми и переиспользуемыми. Каждый координатор предна- значен для решения собственной задачи: для авторизации и регистрации, для управления профилем, для работы с товарными позициями и т.д. Примеров может быть бесконечное множество. Каждый координатор работает с большим количеством сцен. Но при этом они ничего не знают друг о друге – все взаимо- действие между ними происходит через координаторы.
//Если приложению требуется отобразить новую сцену, например, перейти от экрана авторизации к основному экрану со списком товаров, то решение этого  вопроса ложится на плечи координаторов, но не вью контроллеров. Если вам требуется распространить измененные данные (например, о добавленном в корзину товаре) в приложении, для этого также используются координаторы.
// Координатор с программной точки зрения представляет из себя класс, подпи- санный на один или несколько специальных протоколов. Протоколы наделяют класс некой стандартной функциональностью, позволяющей работать с кон- троллерами и обмениваться данными.
// Примечание Конкретные реализации данных протоколов вы сможете найти в моем GitHub в исходном коде приложения Subs Tracker.
// На этом мы завершаем изучение вопроса обмена данными между контроллера- ми внутри ваших приложений. В будущем вы неоднократно вернетесь к этой главе, так что советую оставить закладку.
